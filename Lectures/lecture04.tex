\ProvidesFile{lecture04.tex}[Lecture 4]


Now I want to formulate a second version of the Chinese Remainder Theorem.

\begin{claim}\label{claim::ChineseMult}
Let $m, n\in \mathbb N$ be two coprime positive integers, that is $(m,n) = 1$. Then the map
\[
\Phi \colon \mathbb Z_{mn}^* \to \mathbb Z_m^* \times \mathbb Z_n^*,\quad k\mapsto (k\!\!\mod m, k\!\!\mod n)
\]
is a well-defined isomorphism of groups.
\end{claim}
\begin{proof}
We already know that $\Phi\colon\mathbb Z_{mn}\to \mathbb Z_m \times \mathbb Z_n$ is a bijection. It is clear that $k$ is coprime with $mn$ if and only if $k$ is coprime with $m$ and $k$ is coprime with $n$. The latter means that   $\Phi\colon\mathbb Z_{mn}^*\to \mathbb Z_m^* \times \mathbb Z_n^*$ is a bijection.

Second, we should show that $\Phi$ preserves multiplication. On the one hand
\[
\Phi(k_1k_2)  = (k_1k_2\!\!\mod m, k_1k_2\!\!\mod n)
\]
From the other hand
\[
\Phi(k_1)\Phi(k_2) = (k_1\!\!\mod m, k_1\!\!\mod n)(k_2\!\!\mod m, k_2\!\!\mod n) = (k_1k_2\!\!\mod m, k_1k_2\!\!\mod n)
\]
\end{proof}

This result means that we can reduce computation of $\mathbb Z_n^*$ to the computation of groups $\mathbb Z_{p^k}^*$ where $p$ is prime. Indeed, if $n = p_1^{k_1}\ldots p_r^{k_r}$, then
\[
\mathbb Z_n^* \simeq \mathbb Z_{p_1^{k_1}}^*\times\ldots \times \mathbb Z_{p_r^{k_r}}^*
\]
In order to complete the computation, we need to know the answer for the powers of primes. Here is the required result without proof.

\begin{claim}
If $p$ is an odd prime and $n$ is an arbitrary positive integer, then
\[
\mathbb Z_{p^n}^* \simeq \mathbb Z_{p^{n-1}(p-1)}
\]
is a cyclic group. An integer $a\in \mathbb Z_{p^n}$ is a generator of $\mathbb Z_{p^n}^* $ if and only if $a$ is a generator in $\mathbb Z_p^*$ and $a^{p-1}\neq 1 \pmod{ p^2}$. Hence, every element of $\mathbb Z_{p^n}^*$ is uniquely presented in the form $a^k$, where $0\leqslant k < p^{n-1}(p-1)$.

In case of a power of $2$, the answer is the following
\[
\mathbb Z_{2^n}^*\simeq
\left\{
\begin{aligned}
&0, & &n\leqslant 1\\
&\mathbb Z_2, & &n = 2\\
&\mathbb Z_2\times \mathbb Z_{2^{n-2}}, & &n\geqslant 3
\end{aligned}
\right.
\]
In case $n = 2$, the group is generated by the element $3 = -1$. In case $n \geqslant 3$, the first factor is generated by $2^n - 1 = -1$ and the second factor is generated by $5$. Hence, every element of $\mathbb Z_{2^n}^*$ is uniquely presented in the form $\pm 5^k$, where $0\leqslant k < 2^{n-2}$.
\end{claim}

In particular, the group $\mathbb Z_p^*$ is cyclic of order $p-1$ for any prime $p$. We will show this result latter using some abstract algebra.

\begin{claim}
An element $m\in \mathbb Z_n$ is a generator if and only if $m$ and $n$ are coprime.
\end{claim}
\begin{proof}
($\Rightarrow$). Suppose $(m, n) = d > 1$. Then all elements of $\langle m\rangle$ are divisible by $d$. In particular, we will never get an element $1$. Hence $m$ is not a generator, a contradiction. Therefore $m$ and $n$ are coprime.

($\Leftarrow$). We want to show that $\langle m\rangle = \mathbb Z_n$. Since $1$ is a generator of $\mathbb Z_n$, it is enough to show that $1\in \langle m\rangle$. Since $m$ and $n$ are coprime, there exist elements $a, b\in \mathbb Z$ such that $1 = a m + b n$. Hence $1 = a m \pmod n$. The latter means that $1$ is $a$-th power of $m$, thus, $1 \in \langle m \rangle$.
\end{proof}


\section{Cryptography}

\subsection{The setting}

Suppose there are you, your spouse, and your lover. And you want to send a message to your lover suggesting a private meeting. Also you have seen recently a receipt from a gun store that someone bought a shotgun and you are one hundred percent sure that it was not you. What to do in such a subtle situation? Cryptography to the rescue! The basic idea behind any cryptographic method is this: there are some procedures that are easy to compute in one direction but are very hard to compute in the opposite one, that is the inverse map is difficult to compute. So, it is easy to encrypt the data but hard to decrypt them. But we do not use these procedures as they are because no one will be able to extract the original data. However, using such procedure, we produce a different one. This new procedure is also easy to compute but the inverse map is hard to compute unless you know some secret information. 

Before going straight into details, I need to give you an example of such a procedure. There are two most popular ones.
\begin{itemize}
\item The direct procedure is the multiplication of integer numbers and the inverse one is the factorization of an integer.

\item  The direct procedure is raising to a power in an abelian group and the inverse one is taking logarithm. The inverse one is hard to compute if the abelian group is chosen well enough.
\end{itemize}
Since we are here to utilize some abstract algebra, I am going to focus on the second case. Suppose $G$ is a group (usually finite abelian, but it does not matter for now), $g\in G$ is an arbitrary element, and $n\in \mathbb N$ is a natural number. Then we may compute the element $h = g^n$. It turns out that raising to a power can be done in $O(\log n)$ operations (the algorithm will be explained below). However, suppose now that $h$ is known and either $g$ or $n$ is not. Now, we want to solve one of the following problems
\begin{itemize}
\item $h = (?)^n$ for some $?\in G$.
\item $h = g^?$ for some $?\in \mathbb N$.
\end{itemize}
Whether these problems are hard to compute or not depends on the choice of the group $G$ and the element $h$ in the first case or $g$ in the second one. But if we chose everything carefully, these problems become hard. The first problem is utilized in RSA problem and the second one in Diffie-Hellman exchange procedure. RSA problem is related to factorization problem of composite numbers and is a very popular method. However, I am going to discuss Diffie-Hellman approach only.


\subsection{Exponentiation by squaring}

First I want to explain why raising to a power is a very fast operation. Suppose $G$ is a group, $g\in G$ is an element and $n\in \mathbb N$ is a positive integer. Then, using multiplicative or additive notation, we have
\[
g^n = 
\left\{
\begin{aligned}
&g (g^2)^{k}, & &n = 2k + 1\\
&(g^2)^k, & &n = 2k
\end{aligned}
\right.
\quad\text{or}\quad
ng = 
\left\{
\begin{aligned}
&g + k(2g), & &n = 2k + 1\\
&k (2g), & &n = 2k
\end{aligned}
\right.
\]
So, in multiplicative case, the problem is raising to a power and, in additive case, the problem is multiplying by an integer. I will describe the algorithm for the multiplicative notation only.

\paragraph{Input:} $g\in G$, $n\in \mathbb N$.
\paragraph{Output:}  $g^n\in G$.

We use three internal variables $r, d\in G$ and $k\in \mathbb N$. We maintain the invariant $r d^k = g^n$ all the time. The result will be stored in $r$. The algorithm terminates when $k = 0$.
\paragraph{Algorithm}
\begin{enumerate}
\item Set $r = 1\in G$, $d = g \in G$, $k = n\in \mathbb N$.

\item In a loop, check if $k$ is odd or even. Terminate the loop if $k = 0$.
\begin{enumerate}
\item If $k$ is even. Assign $r = r$, $d = d^2$, $k = k / 2$.
\item If $k$ is odd. Assign $r = r \cdot d$, $d = d^2$, $k = (k-1) / 2$.
\end{enumerate}
\end{enumerate}
\paragraph{Remarks}
During the procedure we have $r d^k = g^n$. At the beginning $r = 1$, $d = g$, $k = n$, so this holds. At each step of the loop we have two cases:
\begin{itemize}
\item $k = 2m$. Then, $r d^{2m} = r (d^2)^m$. And we update $r = r$, $d = d^2$, and $k = m = k/2$.
\item $k = 2m +1$. Then, $r d^{2 m + 1} = (r d) (d^2)^m$. And we update $r = rd$, $d = d^2$, and $k = m = (k - 1) / 2$.
\end{itemize}
There is a similar procedure as follows. Suppose for simplicity that $n = 11$. Then $11 = 1 + 2 + 2^3 = 1 + 2 ( 1 + 2( 0 + 2 ))$. Then
\[
g^{11} = g^{1 + 2 ( 1 + 2( 0 + 2 ))} = g (g^{ 1 + 2( 0 + 2 )})^2 =  g (g (g^{ 0 + 2 })^2)^2 =   g (g (g^{ 2 })^2)^2
\]
If $n = 2^k$, then you need exactly $k$ operations. For example $n = 8 = 2^3$, then $g^8 = ((g^2)^2)^2$. So, there $\log_2 n$  operations. In general, the number of operations is proportional to $\log_2 n$. But I do not want to explain this carefully.

\subsection{The Discrete logarithm problem}\label{section::DiscreteLog}

Let $G$ be  a group, $g\in G$, and $h \in \langle g\rangle$. Then the problem to find $n\in \mathbb N$ such that $g^n = h$ is called the Discrete logarithm problem. Sometimes this procedure is fast sometimes is not. Here are some examples.

\begin{examples}
\begin{enumerate}
\item Let $G = \mathbb Z$ with addition, $g = 1$, and $h = k$. Then it is clear to everyone that the required $n = k$. Indeed, $ng = h$. The problem here is trivial.

\item Let $G = \mathbb Z_m$ with addition, $g = a\in \mathbb Z_m$, and $h = b\in \mathbb Z_n$. Then, the problem is to find $n\in\mathbb N$ such that $na = b \pmod m$. This can be solved effectively using Euclidean division algorithm.

\item Let $p$ be a prime number, $G = \mathbb Z_p^*$ with multiplication and $g = a\in \mathbb Z_p^*$ be a generator of the group, and $h = b\in \mathbb Z_p^*$. Then the problem is to find $n\in \mathbb N$ such that $a^n = b \pmod p$. Well, the experience of the humankind tells us that this problem should be extremely complicated and there is only on option to solve it: the brute force approach.
\end{enumerate}
\end{examples}

\subsection{Diffie-Hellman}

Here I am going to explain the communication process using Diffie-Hellman approach. First, we need to fix a cyclic group $G$, its generator $g\in G$, and we denote the order of $G$ by $n$. A natural choice for $G$ is $\mathbb Z_p^*$, where $p$ is prime. Finding a generator is unpleasant but we should do this only once.

Let me recall the situation we are in. We have three participants: you, your spouse, and your lover. The communication process consists of several steps:
\begin{enumerate}
\item Transform a message (or a part of a message) into an element $t$ of the group $G$.

\item Encrypt the element $t$, that is apply some transformation and get $t'\in G$. The element $t'$ is then broadcasted.

\item The element $t'$ is decrypted using some special information to recover the element $t$.

\item The element $t$ is transformed to the initial message (or the part of the message).
\end{enumerate}
The steps (1) and (4) are usually performed using some table and the table is known to every participant. Do not worry, your spouse knows how to do these steps.



\paragraph{Key exchange}
Before sending any messages you and your lover must do some preparations to produce a private key and only then the communication begins. 

On the diagram below, we show what each participant knows at any step of the process. Let me recall that $G = \langle g\rangle$ and $n = |G|$.
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
{\bf Participants}&{You}&{Your spouse}&{Your lover}\\
\hline
{\bf Knowledge}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}\\
\hline
\end{tabular}
\end{center}

You randomly generate a number $a\in \mathbb Z_n^*$ and compute $r = g^a\in G$. Your lover randomly generates a number $b\in \mathbb Z_n^*$ and computes $s = g^b\in G$.
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
{\bf Participants}&{You}&{Your spouse}&{Your lover}\\
\hline
\multirow{2}{*}{\bf Knowledge}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}\\
{}&{ \textcolor{blue}{$r$}$=$\textcolor{OliveGreen}{$ g$}\textcolor{red}{${}^a$}}&{}&{ \textcolor{blue}{$s$}$=$\textcolor{OliveGreen}{$g$}\textcolor{red}{${}^b$}}\\
\hline
\end{tabular}
\end{center}

You and your lover broadcast elements $r$ and $s$. Hence, everyone knows $r$ and $s$ as the result. But no one knows the elements $a$ and $b$ because this is the discrete logarithm problem in $G$ and we have chosen $G$ and $g\in G$ such that the problem is hard to solve.
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
{\bf Participants}&{You}&{Your spouse}&{Your lover}\\
\hline
\multirow{2}{*}{\bf Knowledge}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}\\
{}&{ \textcolor{blue}{$r$}$=$\textcolor{OliveGreen}{$ g$}\textcolor{red}{${}^a$}, \textcolor{blue}{$s$}}&{\textcolor{blue}{$r$, $s$}}&{ \textcolor{blue}{$s$}$=$\textcolor{OliveGreen}{$g$}\textcolor{red}{${}^b$}, \textcolor{blue}{$r$}}\\
\hline
\end{tabular}
\end{center}

You raise element $s$ to the power $a$ and get $s^a = (g^b)^a = g^{ab}$. Your lover raises $r$ to the power $b$ and gets $r^b = (g^a)^b = g^{ab}$. Now you and your lover know the secret key $k = g^{ab}$.
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
{\bf Participants}&{You}&{Your spouse}&{Your lover}\\
\hline
\multirow{3}{*}{\bf Knowledge}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}\\
{}&{ \textcolor{blue}{$r$}$=$\textcolor{OliveGreen}{$ g$}\textcolor{red}{${}^a$}, \textcolor{blue}{$s$}}&{\textcolor{blue}{$r$, $s$}}&{ \textcolor{blue}{$s$}$=$\textcolor{OliveGreen}{$g$}\textcolor{red}{${}^b$}, \textcolor{blue}{$r$}}\\
{}&{ \textcolor{red}{$k$}$=$\textcolor{blue}{$s$}\textcolor{red}{${}^a$}}&{}&{ \textcolor{red}{$k$}$=$\textcolor{blue}{$r$}\textcolor{red}{${}^b$}}\\
\hline
\end{tabular}
\end{center}

As the result you and your lover know the secret key $k\in G$ and no one even your spouse has a way of finding the key. But in order this to be robust we need to choose $G$ and $g\in G$ carefully. No one wants to find out who bought the shotgun.

\paragraph{Broadcast}

Now its time to send sweet messages to each other. As I have described already, we should translate all the messages to the elements of the group $G$. Suppose we use English alphabet with $26$ symbols. We will use period, comma, exclamation mark, and space symbol as well. Hence, we have $30$ symbols at all. There are $30^m$ sequences with $m$ symbols. If $30^m \leqslant n$, we may map all the sequences to the elements of the group $G$. This allows us to transform messages to sequences of elements of the group $G$.

From now, I am going to ignore the translation stage. Our goal is to send an element of the group $G$. Suppose you have an element $h\in G$ and want to send it to your lover.
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
{\bf Participants}&{You}&{Your spouse}&{Your lover}\\
\hline
\multirow{4}{*}{\bf Knowledge}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}\\
{}&{ \textcolor{blue}{$r$}$=$\textcolor{OliveGreen}{$ g$}\textcolor{red}{${}^a$}, \textcolor{blue}{$s$}}&{\textcolor{blue}{$r$, $s$}}&{ \textcolor{blue}{$s$}$=$\textcolor{OliveGreen}{$g$}\textcolor{red}{${}^b$}, \textcolor{blue}{$r$}}\\
{}&{ \textcolor{red}{$k$}$=$\textcolor{blue}{$s$}\textcolor{red}{${}^a$}}&{}&{ \textcolor{red}{$k$}$=$\textcolor{blue}{$r$}\textcolor{red}{${}^b$}}\\
{}&{\textcolor{red}{$h$}}&{}&{}\\
\hline
\end{tabular}
\end{center}

Now you encrypt your element $h$ multiplying it by the secret $k$ and send the result $m = hk$ to your lover.
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
{\bf Participants}&{You}&{Your spouse}&{Your lover}\\
\hline
\multirow{4}{*}{\bf Knowledge}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}\\
{}&{ \textcolor{blue}{$r$}$=$\textcolor{OliveGreen}{$ g$}\textcolor{red}{${}^a$}, \textcolor{blue}{$s$}}&{\textcolor{blue}{$r$, $s$}}&{ \textcolor{blue}{$s$}$=$\textcolor{OliveGreen}{$g$}\textcolor{red}{${}^b$}, \textcolor{blue}{$r$}}\\
{}&{ \textcolor{red}{$k$}$=$\textcolor{blue}{$s$}\textcolor{red}{${}^a$}}&{}&{ \textcolor{red}{$k$}$=$\textcolor{blue}{$r$}\textcolor{red}{${}^b$}}\\
{}&{\textcolor{red}{$h$}, $\textcolor{blue}{m} = \textcolor{red}{hk}$}&{\textcolor{blue}{$m$}}&{\textcolor{blue}{$m$}}\\
\hline
\end{tabular}
\end{center}

Your lover decrypts the message by computing $h = m k^{-1} = m k^{n - 1}$. It should be noted that the inverse $k^{-1}$ is computed using Corollary~3 of the Lagrange Theorem, that is $k^{-1} = k^{n - 1}$, because $n = |G|$.%
\footnote{If the group $G$ has an effective way to compute the inverse, you should apply that specific algorithm. For example, in case $G = \mathbb Z_p^*$ such an algorithm exists and is based on the extended Euclidean algorithm.}
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
{\bf Participants}&{You}&{Your spouse}&{Your lover}\\
\hline
\multirow{4}{*}{\bf Knowledge}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}\\
{}&{ \textcolor{blue}{$r$}$=$\textcolor{OliveGreen}{$ g$}\textcolor{red}{${}^a$}, \textcolor{blue}{$s$}}&{\textcolor{blue}{$r$, $s$}}&{ \textcolor{blue}{$s$}$=$\textcolor{OliveGreen}{$g$}\textcolor{red}{${}^b$}, \textcolor{blue}{$r$}}\\
{}&{ \textcolor{red}{$k$}$=$\textcolor{blue}{$s$}\textcolor{red}{${}^a$}}&{}&{ \textcolor{red}{$k$}$=$\textcolor{blue}{$r$}\textcolor{red}{${}^b$}}\\
{}&{\textcolor{red}{$h$}, $\textcolor{blue}{m} = \textcolor{red}{hk}$}&{\textcolor{blue}{$m$}}&{\textcolor{blue}{$m$}, $\textcolor{red}{h} = \textcolor{blue}{m} \textcolor{red}{k}^{\textcolor{OliveGreen}{n}-1}$}\\
\hline
\end{tabular}
\end{center}

And voil\`a. No one got shot and the private meeting was worth it.

%\paragraph{Some modifications}
%
%In order to increase robustness of the system we may change the secret key after each $d$ operations, where $d$ is some positive integer. We also may send a pair $(r, m) = (r, hk)= (r, hs^a) = (g^a, h g^{ab})$ to our lover and change the element $a$ each time. Then the decryption is done via $h = m k^{-1} = m (r^b)^{n-1}$.



\paragraph{ElGamal encryption}

In the system described above, the private key $k$ remains the same during the communication process.This fact can be used to compromise the system. In order to increase robustness of the system we may change the secret key after each $d$ messages or even after each message.

Let me describe a one-way communication system based on this idea. First, you must publish your public key. This stage is considered as an invitation to communicate. Now, the lover can send messages to you. On the next stage the lover sends a sequence of messages such that each of the messages is encrypted by its own private key. Below, I will explain the whole process in details.

In order to initiate the incoming transmission, you should invent a secret integer $a\in \mathbb Z_n^*$ and publish the open key $r = g^a$.
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
{\bf Participants}&{You}&{Your spouse}&{Your lover}\\
\hline
\multirow{2}{*}{\bf Knowledge}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}\\
{}&{ \textcolor{blue}{$r$}$=$\textcolor{OliveGreen}{$ g$}\textcolor{red}{${}^a$}}&{\textcolor{blue}{$r$}}&{\textcolor{blue}{$r$}}\\
\hline
\end{tabular}
\end{center}

Now, assume that the lover has a sequence of messages $h_1,\ldots, h_k$. For each message $h_i$ she or he should randomly choose a secret integer $b_i\in\mathbb Z_n^*$. Then the lover generates the corresponding public and private keys as follows $s_i = g^{b_i}$ and $k_i = r^{b_i}$. Then she or he encrypts each message using the private key $m_i = h_i k_i$. And finally, the lover transmits the sequence $(m_1, s_1),\ldots,(m_k, s_k)$.
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
{\bf Participants}&{You}&{Your spouse}&{Your lover}\\
\hline
\multirow{6}{*}{\bf Knowledge}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}\\
{}&{ \textcolor{blue}{$r$}$=$\textcolor{OliveGreen}{$ g$}\textcolor{red}{${}^a$}}&{\textcolor{blue}{$r$}}&{\textcolor{blue}{$r$}}\\
{}&{}&{}&{\textcolor{red}{$h_1,\ldots,h_k$}$\in G$}\\
{}&{}&{}&{\textcolor{red}{$b_1,\ldots,b_k$}$\in \mathbb Z_n^*$}\\
{}&{}&{}&{$\textcolor{blue}{s_i} = \textcolor{OliveGreen}{g}^{\textcolor{red}{b_i}}$, $\textcolor{red}{k_i} = \textcolor{blue}{r}^{\textcolor{red}{b_i}}$}\\
{}&{\textcolor{blue}{$(m_i, s_i)$}}&{\textcolor{blue}{$(m_i, s_i)$}}&{$\textcolor{blue}{m_i} = \textcolor{red}{h_i k_i}$}\\
\hline
\end{tabular}
\end{center}

In order to decrypt  the messages, we should produce the corresponding private key using the public key of the lover $k_i = s_i^a$. Now one else can do this, because now one knows $a$ but you. Then, we recover the original message using the rule $h_i = m_i k_i^{-1}$.
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
{\bf Participants}&{You}&{Your spouse}&{Your lover}\\
\hline
\multirow{7}{*}{\bf Knowledge}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}&{\textcolor{OliveGreen}{$G$}, \textcolor{OliveGreen}{$g$}, \textcolor{OliveGreen}{$n$}}\\
{}&{ \textcolor{blue}{$r$}$=$\textcolor{OliveGreen}{$ g$}\textcolor{red}{${}^a$}}&{\textcolor{blue}{$r$}}&{\textcolor{blue}{$r$}}\\
{}&{}&{}&{\textcolor{red}{$h_1,\ldots,h_k$}$\in G$}\\
{}&{}&{}&{\textcolor{red}{$b_1,\ldots,b_k$}$\in \mathbb Z_n^*$}\\
{}&{}&{}&{$\textcolor{blue}{s_i} = \textcolor{OliveGreen}{g}^{\textcolor{red}{b_i}}$, $\textcolor{red}{k_i} = \textcolor{blue}{r}^{\textcolor{red}{b_i}}$}\\
{}&{\textcolor{blue}{$(m_i, s_i)$}}&{\textcolor{blue}{$(m_i, s_i)$}}&{$\textcolor{blue}{m_i} = \textcolor{red}{h_i k_i}$}\\
{}&{$\textcolor{red}{k_i} = \textcolor{blue}{s_i}^{\textcolor{red}{a}}$, $\textcolor{red}{h_i} = \textcolor{blue}{m_i} \textcolor{red}{k_i}^{-1}$}&{}&{}\\
\hline
\end{tabular}
\end{center}

If we want to communicate in the opposite direction, we should repeat the process from the beginning changing the roles. That is, your lover should publish her or his public key as an invitation to receive messages. And then you repeat the whole process from your side.

\subsection{RSA}

Let me explain the principals of a different encryption system. This one is based on the fact that it is very easy to multiply numbers but hard to factor them. The system is called RSA. This is a one-way communication system.

Suppose we are given $n = p q$, where $p$ and $q$ are distinct prime numbers. Let us take $G = \mathbb Z_n^*$. Using the multiplicative version of the Chinese Remainder Theorem we know that
\[
\mathbb Z_n^* \simeq \mathbb Z_p^*\times \mathbb Z_q^* \simeq \mathbb Z_{p-1}\times \mathbb Z_{q-1}
\]
Hence $|G| = (p-1)(q-1)$. Usually $|\mathbb Z_m^*|$ is denoted by $\varphi(m)$ and is called the Euler function.

Suppose we are given two integers $e, d\in \mathbb Z$ and an element $h\in \mathbb Z_n^*$. If we raise $h$ to the power of $e$, we will get $h^e$. Now we want to recover $h$ by raising $h^e$ to the power $d$. That is, we want $h^{ed} = h$ whenever $h$ is in $\mathbb Z_n^*$. In order to ensure that this happens, it is enough to have $ed = 1 \pmod{\varphi(n)}$. Indeed, 
\[
h^{ed} = h^{1 + |\mathbb Z_n^*|k} = h \left(h^{|\mathbb Z_n^*|}\right)^k = h \text{ in }\mathbb Z_n^*
\]
This means that the map $\mathbb Z_n^* \to \mathbb Z_n^*$ by the rule $h \mapsto h^e$ is a permutation of elements of the group. And if $e$ was chosen randomly, we expect that it is hard to solve the problem $x^e = m$ in $\mathbb Z_n^*$. For example it is a bad idea to take $e$ to be $1$ or $2$ or something like that. If we want to generate $e$ we choose $e$ from $\mathbb Z_{\varphi(n)}^*$. And if $e$ was chosen appropriately solving $x^e = m$ is a hard task.

\paragraph{Establishing a connection}

If you want to make an invitation to receive incoming transmission you need some preparation work to be done. First you need to generate two huge prime numbers $p$ and $q$ and then compute their product $n = pq$. We will use the group $G = \mathbb Z_n^*$ as the set of messages. Thus we publish $n$ and $G$.
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
{\bf Participants}&{You}&{Your spouse}&{Your lover}\\
\hline
{\bf Knowledge}&{\textcolor{red}{$p$, $q$}, $\textcolor{blue}{n} = \textcolor{red}{pq}$}&{\textcolor{blue}{$n$}, $\mathbb Z_n^*$}&{\textcolor{blue}{$n$}, $\mathbb Z_n^*$}\\
\hline
\end{tabular}
\end{center}

Now, we produce an open key as follows. We generate $e\in \mathbb Z_{\varphi(n)}^*$. Then the open key is the pair $(e, n)$.
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
{\bf Participants}&{You}&{Your spouse}&{Your lover}\\
\hline
\multirow{2}{*}{\bf Knowledge}&{\textcolor{red}{$p$, $q$}, $\textcolor{blue}{n} = \textcolor{red}{pq}$}&{\textcolor{blue}{$n$}, $\mathbb Z_n^*$}&{$\mathbb Z_n^*$}\\
{}&{\textcolor{blue}{$e$}}&{\textcolor{blue}{$(e, n)$}}&{\textcolor{blue}{$(e, n)$}}\\
\hline
\end{tabular}
\end{center}

The next step is to generate the private key. We find $d\in \mathbb Z_{\varphi(n)}^*$ such that $de = 1$ in $\mathbb Z_{\varphi(n)}^*$. This can be done using the extended Euclidean algorithm applied to $e$ and $\varphi(n)$. The private key is the pair $(d, n)$.
%Обратите внимание, что никто не может получить $d$, так как для его вычисления надо знать $\varphi(n)$. А для ее вычисления надо знать разложение $n$ на множители, что сложно.
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
{\bf Participants}&{You}&{Your spouse}&{Your lover}\\
\hline
\multirow{3}{*}{\bf Knowledge}&{\textcolor{red}{$p$, $q$}, $\textcolor{blue}{n} = \textcolor{red}{pq}$}&{\textcolor{blue}{$n$}, $\mathbb Z_n^*$}&{$\mathbb Z_n^*$}\\
{}&{\textcolor{blue}{$e$}}&{\textcolor{blue}{$(e, n)$}}&{\textcolor{blue}{$(e, n)$}}\\
{}&{$\textcolor{red}{d}\textcolor{blue}{e} = 1 \pmod{ \textcolor{red}{\varphi(n)}}$}&{}&{}\\
\hline
\end{tabular}
\end{center}


\paragraph{Communication}

Suppose the lover wants to send a message $h\in \mathbb Z_n^*$. She or he encrypts the message using the rule $m = h^e \pmod n$ and sends $m$ by the network.
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
{\bf Participants}&{You}&{Your spouse}&{Your lover}\\
\hline
\multirow{3}{*}{\bf Knowledge}&{\textcolor{red}{$p$, $q$}, $\textcolor{blue}{n} = \textcolor{red}{pq}$}&{\textcolor{blue}{$n$}, $\mathbb Z_n^*$}&{$\mathbb Z_n^*$}\\
{}&{\textcolor{blue}{$e$}}&{\textcolor{blue}{$(e, n)$}}&{\textcolor{blue}{$(e, n)$}}\\
{}&{$\textcolor{red}{d}\textcolor{blue}{e} = 1 \pmod{ \textcolor{red}{\varphi(n)}}$}&{}&{$\textcolor{red}{h}\in \mathbb Z_n^*$}\\
{}&{\textcolor{blue}{$m$}}&{\textcolor{blue}{$m$}}&{$\textcolor{blue}{m} = \textcolor{red}{h}^{\textcolor{blue}{e}} \pmod{\textcolor{blue}{n}$}}\\
\hline
\end{tabular}
\end{center}

In order to decrypt the message we apply the map $h = m^d \pmod n$. This method works because of the choice of $e$ and $d$.
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
{\bf Participants}&{You}&{Your spouse}&{Your lover}\\
\hline
\multirow{4}{*}{\bf Knowledge}&{\textcolor{red}{$p$, $q$}, $\textcolor{blue}{n} = \textcolor{red}{pq}$}&{\textcolor{blue}{$n$}, $\mathbb Z_n^*$}&{$\mathbb Z_n^*$}\\
{}&{\textcolor{blue}{$e$}}&{\textcolor{blue}{$(e, n)$}}&{\textcolor{blue}{$(e, n)$}}\\
{}&{$\textcolor{red}{d}\textcolor{blue}{e} = 1 \pmod{ \textcolor{red}{\varphi(n)}}$}&{}&{$\textcolor{red}{h}\in \mathbb Z_n^*$}\\
{}&{\textcolor{blue}{$m$}}&{\textcolor{blue}{$m$}}&{$\textcolor{blue}{m} = \textcolor{red}{h}^{\textcolor{blue}{e}} \pmod{\textcolor{blue}{n}$}}\\
{}&{$\textcolor{red}{h} = \textcolor{blue}{m}^{\textcolor{red}{d}} \pmod{ \textcolor{blue}{n}}$}&{}&{}\\
\hline
\end{tabular}
\end{center}

Let us discuss why this approach is reliable. As we can see at the beginning of the communication process $p$, $q$, $\varphi(n) = (p-1)(q-1)$, and $d$ is a secret information. However, everyone knows $n = pq$ and $e$ such that $ed = 1 \pmod{\varphi(n)}$. If we know $n$, then it is hard to recover $p$  and $q$ because the factorization is a hard problem. One can show, that if you know $n = pq$, then computation of $\varphi(n)$ is equivalent to knowing $p$ and $q$. Hence, no one knows $\varphi(n)$. Hence, it is impossible to recover $d$ because we do not know two numbers out of three in the equality  $ed = 1 \pmod{\varphi(n)}$. Thus we believe that it is impossible to recover the secret key. When we send a message $h^e$, we believe that solving the equation $x^e = m$ is also hard (there are some requirements on $e$ for this to happen). This more or less explains why the system is robust. If you want to implement this system you should read the official standard explaining details of how to make a good choice of all the parameters.

